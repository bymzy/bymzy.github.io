<!DOCTYPE html>
<html lang="zh-CN">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>æœ¬åœ°æ–‡ä»¶ç®¡ç†å™¨</title>
        <meta name="description" content="ä¸€ä¸ªå¯ä»¥é˜…è¯»PDFå’ŒEPUBæ–‡æ¡£çš„PWAåº”ç”¨">
        <meta name="theme-color" content="#4096ff">
        <link rel="manifest" href="/manifest.json">
        <link rel="icon" href="https://trae-api-cn.mchost.guru/api/ide/v1/text_to_image?prompt=file%20reader%20app%20icon%20with%20document%20symbol%2C%20minimal%20design%2C%20blue%20color&image_size=square" type="image/png">
        <link rel="apple-touch-icon" href="https://trae-api-cn.mchost.guru/api/ide/v1/text_to_image?prompt=file%20reader%20app%20icon%20with%20document%20symbol%2C%20minimal%20design%2C%20blue%20color&image_size=square">
        <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
        <script>
            // æ³¨å†ŒService Worker
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(registration => {
                            console.log('ServiceWorker æ³¨å†ŒæˆåŠŸ:', registration.scope);
                        })
                        .catch(error => {
                            console.log('ServiceWorker æ³¨å†Œå¤±è´¥:', error);
                        });
                });
            }
        </script>
    <style>
        /* ä¿ç•™åŸæœ‰æ‰€æœ‰æ ·å¼ï¼Œæ­¤å¤„çœç•¥ï¼ˆæ ·å¼æ— é—®é¢˜ï¼‰ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f5f7fa;
            overflow: hidden;
        }

        .navbar {
            height: 60px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            position: relative;
            z-index: 100;
        }

        .nav-tabs {
            display: flex;
            gap: 2px;
        }

        .nav-tab {
            padding: 8px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
            font-weight: 500;
            color: #606266;
        }

        .nav-tab.active {
            background-color: #4096ff;
            color: #fff;
        }

        .nav-actions {
            margin-left: auto;
            display: flex;
            gap: 15px;
        }

        .action-btn {
            padding: 8px 16px;
            background-color: #f0f2f5;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #303133;
            font-size: 14px;
        }

        .action-btn:hover {
            background-color: #e5e6eb;
        }

        .action-btn.primary {
            background-color: #4096ff;
            color: #fff;
        }

        .action-btn.primary:hover {
            background-color: #3088ff;
        }

        .breadcrumb {
            height: 40px;
            background-color: #fff;
            padding: 0 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid #e5e6eb;
        }

        .breadcrumb-item {
            cursor: pointer;
            color: #4096ff;
            font-size: 14px;
        }

        .breadcrumb-sep {
            color: #909399;
            font-size: 12px;
        }

        .breadcrumb-item.root {
            color: #303133;
            font-weight: 500;
        }

        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 260px;
            background-color: #fff;
            border-right: 1px solid #e5e6eb;
            overflow-y: auto;
            padding: 10px 0;
        }

        .dir-tree-item {
            padding: 8px 20px;
            cursor: pointer;
            font-size: 14px;
            color: #303133;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s ease;
        }

        .dir-tree-item:hover {
            background-color: #f5f7fa;
        }

        .dir-tree-item.active {
            background-color: #e8f3ff;
            color: #4096ff;
            font-weight: 500;
        }

        .dir-icon {
            font-size: 16px;
        }

        .content-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .empty-state {
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #909399;
            gap: 15px;
        }

        .empty-icon {
            font-size: 64px;
            opacity: 0.5;
        }

        .empty-text {
            font-size: 16px;
        }

        .file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }

        .file-card, .dir-card {
            background-color: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .file-card:hover, .dir-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        .card-thumbnail {
            width: 100%;
            height: 180px;
            background-color: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .dir-card .card-thumbnail {
            background-color: #e8f3ff;
        }

        .thumbnail-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-icon, .dir-icon-card {
            font-size: 48px;
            color: #909399;
        }

        .dir-icon-card {
            color: #4096ff;
        }

        .card-info {
            padding: 15px;
        }

        .file-name, .dir-name {
            font-size: 14px;
            color: #303133;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }

        .file-type, .dir-count {
            font-size: 12px;
            color: #909399;
        }

        .reading-progress {
            font-size: 11px;
            color: #4096ff;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid #e5e6eb;
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255,255,255,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .loading-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #e5e6eb;
            border-top-color: #4096ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .mode-directory .import-mode,
        .mode-import .directory-mode {
            display: none !important;
        }

        /* é˜…è¯»è§†å›¾æ ·å¼ */
        .reader-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #fff;
            z-index: 1000;
            display: none;
            flex-direction: column;
        }

        .reader-header {
            height: 60px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            position: relative;
            z-index: 10;
        }

        .reader-back-btn {
            padding: 8px 16px;
            background-color: #f0f2f5;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #303133;
            font-size: 14px;
        }

        .reader-back-btn:hover {
            background-color: #e5e6eb;
        }

        .reader-title {
            flex: 1;
            font-size: 16px;
            font-weight: 500;
            color: #303133;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .reader-page-info {
            padding: 8px 16px;
            background-color: #f0f2f5;
            border-radius: 6px;
            font-size: 14px;
            color: #303133;
            font-weight: 500;
        }

        .reader-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #pdf-container {
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        #epub-container {
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        .pdf-page {
            margin: 0 auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .epub-view {
            width: 100%;
            height: 100%;
        }
        
        /* ç›®å½•æ ‘æ ·å¼ */
        .sidebar {
            width: 250px;
            background-color: #f5f7fa;
            border-right: 1px solid #e4e7ed;
            overflow-y: auto;
            padding: 10px;
        }

        .dir-tree-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: #606266;
            transition: all 0.2s ease;
        }

        .dir-tree-item:hover {
            background-color: #ecf5ff;
            color: #409eff;
        }

        .dir-tree-item.active {
            background-color: #ecf5ff;
            color: #409eff;
            font-weight: bold;
        }

        .dir-icon {
            margin-right: 8px;
        }
    </style>
</head>
<body class="mode-directory">
    <div class="navbar">
        <div class="nav-tabs">
            <div class="nav-tab active" data-mode="directory">æœ¬åœ°ç›®å½•</div>
            <div class="nav-tab" data-mode="import">å¯¼å…¥æ–‡ä»¶</div>
        </div>
        <div class="nav-actions">
            <button class="action-btn directory-mode" id="select-dir-btn">é€‰æ‹©ç›®å½•</button>
            <button class="action-btn primary import-mode" id="import-file-btn">å¯¼å…¥æ–‡ä»¶</button>
            <button class="action-btn import-mode" id="clear-import-btn">æ¸…ç©ºå¯¼å…¥</button>
        </div>
    </div>

    <div class="breadcrumb directory-mode" id="breadcrumb">
        <div class="breadcrumb-item root" data-path="">æ ¹ç›®å½•</div>
    </div>

    <div class="content-wrapper">
        <div class="sidebar directory-mode" id="dir-tree"></div>

        <div class="content-area">
            <div class="empty-state" id="empty-state">
                <div class="empty-icon">ğŸ“‚</div>
                <div class="empty-text">æš‚æ— æ–‡ä»¶ï¼Œè¯·é€‰æ‹©æœ¬åœ°ç›®å½•æˆ–å¯¼å…¥æ–‡ä»¶</div>
            </div>

            <div class="file-grid" id="fileGrid"></div>
        </div>
    </div>

    <!-- é˜…è¯»è§†å›¾ -->
    <div class="reader-view" id="readerView">
        <div class="reader-header">
            <button class="reader-back-btn" id="readerBackBtn">è¿”å›</button>
            <div class="reader-title" id="readerTitle"></div>
            <div class="reader-page-info" id="readerPageInfo"></div>
        </div>
        <div class="reader-content">
            <div id="pdf-container"></div>
            <div id="epub-container"></div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

        const state = {
            currentMode: 'directory',
            currentDirHandle: null,
            currentDirPath: '',
            dirTree: [],
            importedFiles: JSON.parse(localStorage.getItem('importedFiles') || '[]'),
            fileCache: new Map()
        };

        const elements = {
            body: document.body,
            navTabs: document.querySelectorAll('.nav-tab'),
            selectDirBtn: document.getElementById('select-dir-btn'),
            importFileBtn: document.getElementById('import-file-btn'),
            clearImportBtn: document.getElementById('clear-import-btn'),
            breadcrumb: document.getElementById('breadcrumb'),
            dirTree: document.getElementById('dir-tree'),
            emptyState: document.getElementById('empty-state'),
            fileGrid: document.getElementById('fileGrid'),
            fileInput: null,
            // é˜…è¯»è§†å›¾ç›¸å…³å…ƒç´ 
            readerView: document.getElementById('readerView'),
            readerBackBtn: document.getElementById('readerBackBtn'),
            readerTitle: document.getElementById('readerTitle'),
            readerPageInfo: document.getElementById('readerPageInfo'),
            pdfContainer: document.getElementById('pdf-container'),
            epubContainer: document.getElementById('epub-container')
        };

        init();

        function init() {
            createFileInput();
            
            elements.navTabs.forEach(tab => {
                tab.addEventListener('click', switchMode);
            });

            elements.selectDirBtn.addEventListener('click', selectDirectory);
            
            elements.importFileBtn.addEventListener('click', () => {
                elements.fileInput.click();
            });

            elements.clearImportBtn.addEventListener('click', clearImportedFiles);

            elements.fileInput.addEventListener('change', handleFileImport);

            // é˜…è¯»è§†å›¾è¿”å›æŒ‰é’®äº‹ä»¶
            elements.readerBackBtn.addEventListener('click', () => {
                // ç§»é™¤é”®ç›˜äº‹ä»¶ç›‘å¬å™¨
                if (state.keyPressHandler) {
                    document.removeEventListener('keydown', state.keyPressHandler);
                    state.keyPressHandler = null;
                    console.log('é”®ç›˜äº‹ä»¶ç›‘å¬å™¨ç§»é™¤æˆåŠŸ');
                }
                
                // æ¸…ç†å½“å‰æ¸²æŸ“å®ä¾‹
                if (state.currentRendition) {
                    state.currentRendition = null;
                }
                
                // ç§»é™¤æ‰€æœ‰ç›®å½•é¢æ¿
                const existingPdfTocPanel = document.getElementById('pdf-toc-panel');
                if (existingPdfTocPanel) {
                    existingPdfTocPanel.remove();
                }
                const existingEpubTocPanel = document.getElementById('epub-toc-panel');
                if (existingEpubTocPanel) {
                    existingEpubTocPanel.remove();
                }
                
                // éšè—é˜…è¯»è§†å›¾å¹¶æ¸…ç†å†…å®¹
                elements.readerView.style.display = 'none';
                elements.pdfContainer.innerHTML = '';
                elements.epubContainer.innerHTML = '';
            });

            if (state.importedFiles.length > 0) {
                renderImportedFiles();
            }
        }

        function switchMode(e) {
            const mode = e.target.dataset.mode;
            if (mode === state.currentMode) return;

            elements.navTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.mode === mode);
            });

            elements.body.classList.remove('mode-directory', 'mode-import');
            elements.body.classList.add(`mode-${mode}`);

            state.currentMode = mode;

            if (mode === 'directory') {
                if (state.currentDirHandle) {
                    renderDirectoryContent(state.currentDirHandle, state.currentDirPath);
                } else {
                    showEmptyState();
                }
            } else if (mode === 'import') {
                renderImportedFiles();
            }
        }

        async function selectDirectory() {
            try {
                const dirHandle = await window.showDirectoryPicker();
                state.currentDirHandle = dirHandle;
                state.currentDirPath = '';
                
                state.dirTree = []; // é‡ç½®ç›®å½•æ ‘
                await buildDirTree(dirHandle, '');
                
                renderDirTree();
                renderBreadcrumb('');
                await renderDirectoryContent(dirHandle, '');
            } catch (err) {
                if (err.name !== 'AbortError') {
                    alert(`é€‰æ‹©ç›®å½•å¤±è´¥ï¼š${err.message}`);
                }
            }
        }

        async function buildDirTree(dirHandle, path) {
            state.dirTree.push({
                handle: dirHandle,
                path: path,
                name: dirHandle.name || 'æ ¹ç›®å½•'
            });

            for await (const [name, handle] of dirHandle.entries()) {
                if (handle.kind === 'directory') {
                    const subPath = path ? `${path}/${name}` : name;
                    await buildDirTree(handle, subPath);
                }
            }
        }

        function renderDirTree() {
            elements.dirTree.innerHTML = '';
            
            state.dirTree.forEach(dir => {
                const treeItem = document.createElement('div');
                treeItem.className = `dir-tree-item ${dir.path === state.currentDirPath ? 'active' : ''}`;
                treeItem.dataset.path = dir.path;
                treeItem.innerHTML = `
                    <span class="dir-icon">ğŸ“</span>
                    <span>${dir.name}</span>
                `;
                
                treeItem.addEventListener('click', async () => {
                    const targetDir = state.dirTree.find(item => item.path === dir.path);
                    if (targetDir) {
                        state.currentDirPath = dir.path;
                        state.currentDirHandle = targetDir.handle;
                        
                        elements.dirTree.querySelectorAll('.dir-tree-item').forEach(item => {
                            item.classList.toggle('active', item.dataset.path === dir.path);
                        });
                        
                        renderBreadcrumb(dir.path);
                        await renderDirectoryContent(targetDir.handle, dir.path);
                    }
                });
                
                elements.dirTree.appendChild(treeItem);
            });
        }

        function renderBreadcrumb(path) {
            elements.breadcrumb.innerHTML = '';
            
            const rootItem = document.createElement('div');
            rootItem.className = 'breadcrumb-item root';
            rootItem.dataset.path = '';
            rootItem.textContent = 'æ ¹ç›®å½•';
            rootItem.addEventListener('click', async () => {
                const rootDir = state.dirTree.find(item => item.path === '');
                if (rootDir) {
                    state.currentDirPath = '';
                    state.currentDirHandle = rootDir.handle;
                    renderBreadcrumb('');
                    renderDirTree();
                    await renderDirectoryContent(rootDir.handle, '');
                }
            });
            elements.breadcrumb.appendChild(rootItem);

            if (!path) return;

            const pathParts = path.split('/');
            let currentPath = '';
            
            pathParts.forEach(part => {
                if (!part) return;
                
                const sep = document.createElement('div');
                sep.className = 'breadcrumb-sep';
                sep.textContent = '/';
                elements.breadcrumb.appendChild(sep);
                
                currentPath = currentPath ? `${currentPath}/${part}` : part;
                
                const dirItem = document.createElement('div');
                dirItem.className = 'breadcrumb-item';
                dirItem.dataset.path = currentPath;
                dirItem.textContent = part;
                dirItem.addEventListener('click', async () => {
                    const targetDir = state.dirTree.find(item => item.path === currentPath);
                    if (targetDir) {
                        state.currentDirPath = currentPath;
                        state.currentDirHandle = targetDir.handle;
                        renderDirTree();
                        await renderDirectoryContent(targetDir.handle, currentPath);
                    }
                });
                elements.breadcrumb.appendChild(dirItem);
            });
        }

        async function renderDirectoryContent(dirHandle, path) {
            try {
                elements.fileGrid.innerHTML = '';
                hideEmptyState();

                const items = [];
                for await (const [name, handle] of dirHandle.entries()) {
                    items.push({ name, handle, path: path ? `${path}/${name}` : name });
                }

                items.sort((a, b) => {
                    if (a.handle.kind === 'directory' && b.handle.kind === 'file') return -1;
                    if (a.handle.kind === 'file' && b.handle.kind === 'directory') return 1;
                    return a.name.localeCompare(b.name);
                });

                for (const item of items) {
                    if (item.handle.kind === 'directory') {
                        renderDirCard(item);
                    } else if (item.handle.kind === 'file' && isSupportedFile(item.name)) {
                        // å…³é”®ä¿®å¤ï¼šå…ˆä» FileSystemFileHandle è·å– File å¯¹è±¡
                        const file = await item.handle.getFile();
                        await renderFileCard(file, item.name);
                    }
                }

                if (elements.fileGrid.children.length === 0) {
                    showEmptyState();
                }
            } catch (err) {
                alert(`åŠ è½½ç›®å½•å¤±è´¥ï¼š${err.message}`);
                showEmptyState();
            }
        }

        function renderDirCard(item) {
            const card = document.createElement('div');
            card.className = 'dir-card';
            card.innerHTML = `
                <div class="card-thumbnail">
                    <div class="dir-icon-card">ğŸ“</div>
                </div>
                <div class="card-info">
                    <div class="dir-name">${item.name}</div>
                    <div class="dir-count">æ–‡ä»¶å¤¹</div>
                </div>
            `;
            
            card.addEventListener('click', async () => {
                const subDir = state.dirTree.find(dir => dir.path === item.path);
                if (subDir) {
                    state.currentDirPath = item.path;
                    state.currentDirHandle = subDir.handle;
                    renderDirTree();
                    renderBreadcrumb(item.path);
                    await renderDirectoryContent(subDir.handle, item.path);
                }
            });
            
            elements.fileGrid.appendChild(card);
        }

        function handleFileImport(e) {
            const files = e.target.files;
            if (!files.length) return;

            const newFiles = [];
            for (const file of files) {
                if (!isSupportedFile(file.name)) continue;
                
                const isDuplicate = state.importedFiles.some(
                    f => f.name === file.name && f.size === file.size && f.lastModified === file.lastModified
                );
                
                if (!isDuplicate) {
                    const fileObj = {
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified,
                        data: null
                    };
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        fileObj.data = e.target.result;
                        state.importedFiles.push(fileObj);
                        localStorage.setItem('importedFiles', JSON.stringify(state.importedFiles));
                        if (state.currentMode === 'import') {
                            renderImportedFiles();
                        }
                    };
                    reader.readAsDataURL(file);
                    newFiles.push(fileObj);
                }
            }

            if (newFiles.length > 0) {
                alert(`æˆåŠŸå¯¼å…¥ ${newFiles.length} ä¸ªæ–‡ä»¶`);
            } else {
                alert('æœªå¯¼å…¥æ–°æ–‡ä»¶ï¼ˆæ–‡ä»¶ç±»å‹ä¸æ”¯æŒæˆ–å·²é‡å¤ï¼‰');
            }

            elements.fileInput.value = '';
        }

        function renderImportedFiles() {
            elements.fileGrid.innerHTML = '';
            
            if (state.importedFiles.length === 0) {
                showEmptyState();
                return;
            }
            
            hideEmptyState();
            
            state.importedFiles.forEach(fileObj => {
                const byteString = atob(fileObj.data.split(',')[1]);
                const mimeString = fileObj.data.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                const file = new File([ab], fileObj.name, { 
                    type: mimeString || fileObj.type 
                });
                
                renderFileCard(file, fileObj.name);
            });
        }

        function clearImportedFiles() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å·²å¯¼å…¥çš„æ–‡ä»¶å—ï¼Ÿ')) {
                state.importedFiles = [];
                localStorage.removeItem('importedFiles');
                renderImportedFiles();
            }
        }

        async function renderFileCard(file, fileName) {
            const cacheKey = `${fileName}-${file.size}-${file.lastModified}`;
            
            // è·å–é˜…è¯»è¿›åº¦ä¿¡æ¯
            const progressInfo = getReadingProgressInfo(fileName, file.size, file.lastModified);
            
            if (state.fileCache.has(cacheKey)) {
                const cachedHtml = state.fileCache.get(cacheKey);
                const card = document.createElement('div');
                card.className = 'file-card';
                card.innerHTML = cachedHtml;
                elements.fileGrid.appendChild(card);
                
                // æ›´æ–°é˜…è¯»è¿›åº¦ä¿¡æ¯
                updateProgressInfo(card, progressInfo);
                
                // ä¸ºç¼“å­˜çš„å¡ç‰‡æ·»åŠ ç‚¹å‡»äº‹ä»¶
                addFileCardClickEvent(card, file, fileName);
                return;
            }

            const card = document.createElement('div');
            card.className = 'file-card';
            card.innerHTML = `
                <div class="card-thumbnail">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                    <div class="file-icon">ğŸ“„</div>
                </div>
                <div class="card-info">
                    <div class="file-name">${fileName}</div>
                    <div class="file-type">${getFileTypeName(file.type || fileName)}</div>
                    ${progressInfo ? `<div class="reading-progress">${progressInfo}</div>` : ''}
                </div>
            `;
            elements.fileGrid.appendChild(card);

            // ä¸ºå¡ç‰‡æ·»åŠ ç‚¹å‡»äº‹ä»¶
            addFileCardClickEvent(card, file, fileName);

            const thumbnailContainer = card.querySelector('.card-thumbnail');
            const loading = card.querySelector('.loading');
            const fileIcon = card.querySelector('.file-icon');

            try {
                if (fileName.endsWith('.pdf')) {
                    const fileUrl = URL.createObjectURL(file);
                    const pdf = await pdfjsLib.getDocument(fileUrl).promise;
                    
                    // ä¿å­˜PDFæ€»é¡µæ•°åˆ°localStorage
                    const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                    const existingProgress = JSON.parse(localStorage.getItem(progressKey) || '{}');
                    if (!existingProgress.totalPages) {
                        existingProgress.totalPages = pdf.numPages;
                        existingProgress.currentPage = existingProgress.currentPage || 0;
                        localStorage.setItem(progressKey, JSON.stringify(existingProgress));
                    }
                    
                    // æ›´æ–°å¡ç‰‡ä¸Šçš„è¿›åº¦ä¿¡æ¯
                    const updatedProgressInfo = getReadingProgressInfo(fileName, file.size, file.lastModified);
                    updateProgressInfo(card, updatedProgressInfo);
                    
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 1.5 });
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    
                    await page.render({ canvasContext: ctx, viewport }).promise;
                    
                    const img = document.createElement('img');
                    img.className = 'thumbnail-img';
                    img.src = canvas.toDataURL('image/png');
                    thumbnailContainer.innerHTML = '';
                    thumbnailContainer.appendChild(img);
                    
                    URL.revokeObjectURL(fileUrl);
                } 
                else if (fileName.endsWith('.epub')) {
                    // æ­¤å¤„ä¼ å…¥çš„ file å·²æ˜¯ File å¯¹è±¡ï¼Œå¯æ­£å¸¸è¯»å–
                    const arrayBuffer = await readFileAsArrayBuffer(file);
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    const coverPaths = [
                        'OEBPS/cover.jpg', 'OEBPS/cover.png',
                        'OEBPS/images/cover.jpg', 'OEBPS/images/cover.png',
                        'cover.jpg', 'cover.png'
                    ];
                    
                    let coverFile = null;
                    for (const path of coverPaths) {
                        if (zip.files[path]) {
                            coverFile = zip.files[path];
                            break;
                        }
                    }
                    
                    if (coverFile) {
                        const coverData = await coverFile.async('base64');
                        const img = document.createElement('img');
                        img.className = 'thumbnail-img';
                        img.src = `data:image/${coverFile.name.split('.').pop()};base64,${coverData}`;
                        thumbnailContainer.innerHTML = '';
                        thumbnailContainer.appendChild(img);
                    } else {
                        fileIcon.textContent = 'ğŸ“–';
                    }
                    
                    // å°è¯•ä½¿ç”¨epub.jsè·å–EPUBæ€»ç« èŠ‚æ•°å¹¶ä¿å­˜åˆ°localStorage
                    try {
                        if (typeof ePub !== 'undefined') {
                            const book = ePub(arrayBuffer);
                            book.loaded.navigation.then(function(toc) {
                                const totalChapters = toc.length;
                                console.log('EPUBæ€»ç« èŠ‚æ•°:', totalChapters);
                                
                                // ä¿å­˜EPUBæ€»ç« èŠ‚æ•°åˆ°localStorage
                                const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                                const existingProgress = JSON.parse(localStorage.getItem(progressKey) || '{}');
                                if (!existingProgress.totalChapters) {
                                    existingProgress.totalChapters = totalChapters;
                                    existingProgress.currentChapter = existingProgress.currentChapter || 0;
                                    localStorage.setItem(progressKey, JSON.stringify(existingProgress));
                                    
                                    // æ›´æ–°å¡ç‰‡ä¸Šçš„è¿›åº¦ä¿¡æ¯
                                    const updatedProgressInfo = getReadingProgressInfo(fileName, file.size, file.lastModified);
                                    updateProgressInfo(card, updatedProgressInfo);
                                }
                            });
                        }
                    } catch (err) {
                        console.log('è·å–EPUBç« èŠ‚æ•°å¤±è´¥:', err);
                    }
                } 
                else {
                    fileIcon.textContent = getFileIcon(fileName);
                }

                loading.remove();
                // ä¸ç¼“å­˜åŒ…å«è¿›åº¦ä¿¡æ¯çš„å¡ç‰‡ï¼Œå› ä¸ºè¿›åº¦ä¼šå˜åŒ–
            } catch (err) {
                console.error(`å¤„ç†æ–‡ä»¶ ${fileName} å¤±è´¥:`, err);
                fileIcon.textContent = 'âŒ';
                loading.remove();
            }
        }

        // è·å–é˜…è¯»è¿›åº¦ä¿¡æ¯
        function getReadingProgressInfo(fileName, fileSize, lastModified) {
            const progressKey = `reading_progress_${fileName}_${fileSize}_${lastModified}`;
            const progressData = JSON.parse(localStorage.getItem(progressKey) || 'null');
            
            // å¦‚æœæ²¡æœ‰é˜…è¯»è¿›åº¦ï¼Œè¿”å›null
            if (!progressData || (!progressData.currentPage && !progressData.currentChapter)) {
                return null;
            }
            
            const currentPage = progressData.currentPage || progressData.currentChapter;
            // å¯¹äºPDFæ–‡ä»¶ï¼Œå°è¯•ä»æ–‡ä»¶åå’Œå¤§å°æ¨æ–­æ€»é¡µæ•°
            let totalPages = progressData.totalPages || progressData.totalChapters || 1;
            
            // å¦‚æœæ²¡æœ‰å­˜å‚¨æ€»é¡µæ•°ï¼Œå°è¯•ä»æ–‡ä»¶åä¸­æå–ï¼ˆå¦‚æœæ–‡ä»¶ååŒ…å«é¡µæ•°ä¿¡æ¯ï¼‰
            if (totalPages === 1) {
                const pageMatch = fileName.match(/\((\d+)é¡µ\)/i);
                if (pageMatch && pageMatch[1]) {
                    totalPages = parseInt(pageMatch[1]);
                }
            }
            
            // åªæœ‰å½“æ€»é¡µæ•°å¤§äº1ä¸”å½“å‰é¡µæ•°å¤§äº0æ—¶ï¼Œæ‰æ˜¾ç¤ºè¿›åº¦ä¿¡æ¯
            if (totalPages <= 1 || currentPage <= 0) {
                return null;
            }
            
            const percentage = Math.round((currentPage / totalPages) * 100);
            const remainingPages = totalPages - currentPage;
            
            return `å·²è¯» ${currentPage} é¡µï¼Œå‰©ä½™ ${remainingPages} é¡µ (${percentage}%)`;
        }

        // æ›´æ–°å¡ç‰‡ä¸Šçš„é˜…è¯»è¿›åº¦ä¿¡æ¯
        function updateProgressInfo(card, progressInfo) {
            let progressElement = card.querySelector('.reading-progress');
            
            if (progressInfo) {
                if (!progressElement) {
                    progressElement = document.createElement('div');
                    progressElement.className = 'reading-progress';
                    card.querySelector('.card-info').appendChild(progressElement);
                }
                progressElement.textContent = progressInfo;
            } else if (progressElement) {
                progressElement.remove();
            }
        }

        // ä¸ºæ–‡ä»¶å¡ç‰‡æ·»åŠ ç‚¹å‡»äº‹ä»¶
        function addFileCardClickEvent(card, file, fileName) {
            card.addEventListener('click', async () => {
                if (fileName.endsWith('.pdf')) {
                    await openPdfReader(file, fileName);
                } else if (fileName.endsWith('.epub')) {
                    await openEpubReader(file, fileName);
                } else {
                    // å…¶ä»–æ–‡ä»¶ç±»å‹å¯ä»¥æ·»åŠ ç›¸åº”çš„å¤„ç†é€»è¾‘
                    alert(`æš‚ä¸æ”¯æŒé˜…è¯» ${getFileTypeName(fileName)} ç±»å‹çš„æ–‡ä»¶`);
                }
            });
        }

        // æ‰“å¼€PDFé˜…è¯»å™¨ - ç¿»é¡µæ¨¡å¼
        async function openPdfReader(file, fileName) {
            // æ˜¾ç¤ºé˜…è¯»è§†å›¾
            elements.readerView.style.display = 'flex';
            elements.readerTitle.textContent = fileName;
            elements.pdfContainer.style.display = 'block';
            elements.epubContainer.style.display = 'none';
            elements.pdfContainer.innerHTML = '';

            try {
                console.log('å¼€å§‹å¤„ç†PDFæ–‡ä»¶:', fileName);
                
                // ç›´æ¥ä»Fileå¯¹è±¡è¯»å–æ•°æ®ï¼Œä¸ä½¿ç”¨ä¸´æ—¶URL
                const arrayBuffer = await file.arrayBuffer();
                console.log('PDFæ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¤§å°:', arrayBuffer.byteLength, 'å­—èŠ‚');
                
                // ä½¿ç”¨PDF.jsç›´æ¥åŠ è½½ArrayBuffer
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                console.log('PDFæ–‡æ¡£åŠ è½½æˆåŠŸï¼Œé¡µæ•°:', pdf.numPages);

                // è·å–é˜…è¯»è¿›åº¦
                const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                const savedProgress = JSON.parse(localStorage.getItem(progressKey));
                let currentPage = savedProgress.currentPage || 1;

                // åˆå§‹åŒ–ç¼©æ”¾çº§åˆ«
                let currentScale = 1.0;
                
                // åˆå§‹åŒ–ç›®å½•æ•°æ®
                let pdfOutline = [];
                
                // è·å–PDFç›®å½•
                try {
                    pdfOutline = await pdf.getOutline();
                    console.log('PDFç›®å½•è·å–æˆåŠŸï¼Œæ¡ç›®æ•°:', pdfOutline.length);
                    
                    // ç¼“å­˜ç›®å½•ä¿¡æ¯åˆ°localStorage
                    const outlineKey = `pdf_outline_${fileName}_${file.size}_${file.lastModified}`;
                    // è½¬æ¢ç›®å½•æ•°æ®ä¸ºå¯åºåˆ—åŒ–æ ¼å¼
                    const serializableOutline = JSON.parse(JSON.stringify(pdfOutline));
                    localStorage.setItem(outlineKey, JSON.stringify(serializableOutline));
                } catch (err) {
                    console.log('PDFæ— ç›®å½•æˆ–è·å–ç›®å½•å¤±è´¥:', err);
                    pdfOutline = [];
                }
                
                // æ£€æŸ¥å¹¶ç§»é™¤å·²å­˜åœ¨çš„ç›®å½•é¢æ¿ï¼ˆåŒ…æ‹¬EPUBçš„ç›®å½•é¢æ¿ï¼‰
                const existingPdfTocPanel = document.getElementById('pdf-toc-panel');
                if (existingPdfTocPanel) {
                    existingPdfTocPanel.remove();
                }
                const existingEpubTocPanel = document.getElementById('epub-toc-panel');
                if (existingEpubTocPanel) {
                    existingEpubTocPanel.remove();
                }
                
                // ä¿®æ”¹é˜…è¯»è§†å›¾å¸ƒå±€ï¼Œæ·»åŠ ç›®å½•é¢æ¿
                const readerContent = elements.pdfContainer.parentElement;
                readerContent.style.display = 'flex';
                readerContent.style.overflow = 'hidden';
                
                // åˆ›å»ºç›®å½•é¢æ¿
                const tocPanel = document.createElement('div');
                tocPanel.id = 'pdf-toc-panel';
                tocPanel.style.width = '250px';
                tocPanel.style.height = '100%';
                tocPanel.style.backgroundColor = '#f5f7fa';
                tocPanel.style.borderRight = '1px solid #e0e0e0';
                tocPanel.style.padding = '15px';
                tocPanel.style.overflowY = 'auto';
                tocPanel.style.flexShrink = '0';
                tocPanel.style.position = 'relative';
                tocPanel.style.zIndex = '10';
                
                // ç›®å½•æ ‡é¢˜
                const tocTitle = document.createElement('div');
                tocTitle.style.fontSize = '16px';
                tocTitle.style.fontWeight = '500';
                tocTitle.style.marginBottom = '15px';
                tocTitle.style.color = '#303133';
                tocTitle.textContent = 'ç›®å½•';
                tocPanel.appendChild(tocTitle);
                
                // æ¸²æŸ“ç›®å½•
                function renderTOC(outline, container, level = 0) {
                    if (!outline || outline.length === 0) {
                        const noTocMsg = document.createElement('div');
                        noTocMsg.style.fontSize = '14px';
                        noTocMsg.style.color = '#909399';
                        noTocMsg.style.textAlign = 'center';
                        noTocMsg.textContent = 'è¯¥PDFæ— ç›®å½•';
                        container.appendChild(noTocMsg);
                        return;
                    }
                    
                    const ul = document.createElement('ul');
                    ul.style.listStyle = 'none';
                    ul.style.padding = '0';
                    ul.style.margin = '0';
                    
                    outline.forEach(item => {
                        const li = document.createElement('li');
                        li.style.marginBottom = '8px';
                        li.style.paddingLeft = `${level * 15}px`;
                        
                        const tocItem = document.createElement('div');
                        tocItem.style.fontSize = '14px';
                        tocItem.style.color = '#4096ff';
                        tocItem.style.cursor = 'pointer';
                        tocItem.style.padding = '5px 8px';
                        tocItem.style.borderRadius = '4px';
                        tocItem.style.transition = 'background-color 0.2s ease';
                        tocItem.textContent = item.title;
                        
                        tocItem.addEventListener('mouseover', () => {
                            tocItem.style.backgroundColor = '#e8f3ff';
                        });
                        
                        tocItem.addEventListener('mouseout', () => {
                            tocItem.style.backgroundColor = 'transparent';
                        });
                        
                        tocItem.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            // è·³è½¬åˆ°å¯¹åº”é¡µé¢
                            if (item.dest) {
                                console.log('page index: ', await pdf.getPageIndex(item.dest[0]));
                                goToPage(await pdf.getPageIndex(item.dest[0]));
                            }
                        });
                        
                        li.appendChild(tocItem);
                        
                        // æ¸²æŸ“å­ç›®å½•
                        if (item.items && item.items.length > 0) {
                            const subContainer = document.createElement('div');
                            subContainer.style.display = 'none'; // é»˜è®¤æŠ˜å 
                            renderTOC(item.items, subContainer, level + 1);
                            li.appendChild(subContainer);
                            
                            // æ·»åŠ å±•å¼€/æŠ˜å æŒ‰é’®
                            const toggleBtn = document.createElement('span');
                            toggleBtn.style.display = 'inline-block';
                            toggleBtn.style.width = '16px';
                            toggleBtn.style.height = '16px';
                            toggleBtn.style.textAlign = 'center';
                            toggleBtn.style.marginRight = '5px';
                            toggleBtn.style.fontSize = '12px';
                            toggleBtn.textContent = 'â–¶';
                            toggleBtn.style.transform = 'rotate(0deg)';
                            toggleBtn.style.transition = 'transform 0.2s ease';
                            
                            tocItem.insertBefore(toggleBtn, tocItem.firstChild);
                            
                            // ä¸ºå±•å¼€/æŠ˜å æŒ‰é’®æ·»åŠ å•ç‹¬çš„ç‚¹å‡»äº‹ä»¶
                            toggleBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                if (subContainer.style.display === 'none') {
                                    subContainer.style.display = 'block';
                                    toggleBtn.style.transform = 'rotate(90deg)';
                                } else {
                                    subContainer.style.display = 'none';
                                    toggleBtn.style.transform = 'rotate(0deg)';
                                }
                            });
                        }
                        
                        ul.appendChild(li);
                    });
                    
                    container.appendChild(ul);
                }
                
                // æ¸²æŸ“ç›®å½•
                renderTOC(pdfOutline, tocPanel);
                
                // æ’å…¥ç›®å½•é¢æ¿åˆ°é˜…è¯»å†…å®¹åŒºåŸŸ
                readerContent.insertBefore(tocPanel, elements.pdfContainer);
                
                // è°ƒæ•´PDFå®¹å™¨æ ·å¼
                elements.pdfContainer.style.flex = '1';
                elements.pdfContainer.style.overflow = 'auto';
                elements.pdfContainer.style.position = 'relative';
                elements.pdfContainer.style.zIndex = '5';
                
                // æ¸²æŸ“é¡µé¢å‡½æ•°
                async function renderPages() {
                    elements.pdfContainer.innerHTML = '';
                    
                    // åˆ›å»ºå†…éƒ¨å®¹å™¨ï¼Œç”¨äºå­˜æ”¾é¡µé¢å†…å®¹
                    const contentWrapper = document.createElement('div');
                    contentWrapper.style.display = 'flex';
                    contentWrapper.style.justifyContent = 'center';
                    contentWrapper.style.alignItems = 'flex-start';
                    contentWrapper.style.gap = '0px'; // ç§»é™¤é—´è·ï¼Œè®©é¡µé¢è¾¹ç¼˜ç›¸è¿
                    contentWrapper.style.padding = '20px';
                    contentWrapper.style.flexWrap = 'nowrap';
                    
                    // è®¡ç®—è¦æ˜¾ç¤ºçš„é¡µé¢èŒƒå›´ï¼ˆæ€»æ˜¯æ˜¾ç¤º2é¡µï¼‰
                    const pagesToShow = [];
                    pagesToShow.push(currentPage);
                    if (currentPage < pdf.numPages) {
                        pagesToShow.push(currentPage + 1);
                    } else if (currentPage > 1) {
                        // å¦‚æœæ˜¯æœ€åä¸€é¡µï¼Œæ˜¾ç¤ºå‰ä¸€é¡µå’Œå½“å‰é¡µ
                        pagesToShow.unshift(currentPage - 1);
                    }

                    // æ¸²æŸ“é€‰ä¸­çš„é¡µé¢
                    for (const pageNum of pagesToShow) {
                        console.log(`æ¸²æŸ“é¡µé¢ ${pageNum}`);
                        const page = await pdf.getPage(pageNum);
                        // ä¿æŒè¾ƒé«˜çš„æ¸²æŸ“åˆ†è¾¨ç‡ï¼Œç¡®ä¿æ¸…æ™°åº¦
                        const baseScale = 2.0; // åŸºç¡€æ¸²æŸ“åˆ†è¾¨ç‡
                        const viewport = page.getViewport({ scale: baseScale * currentScale });
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        canvas.className = 'pdf-page';
                        // ä½¿ç”¨å›ºå®šåƒç´ å®½åº¦ï¼Œç¡®ä¿å†…å®¹èƒ½æ­£ç¡®æ»šåŠ¨
                        canvas.style.width = `${viewport.width / baseScale}px`;
                        canvas.style.height = `${viewport.height / baseScale}px`;
                        canvas.style.boxShadow = pageNum === currentPage ? '0 4px 12px rgba(64, 150, 255, 0.3)' : '0 2px 8px rgba(0,0,0,0.1)';
                        canvas.style.opacity = pageNum === currentPage ? '1' : '0.9';
                        canvas.style.borderRadius = '0px'; // ç§»é™¤åœ†è§’ï¼Œè®©é¡µé¢è¾¹ç¼˜ç›¸è¿
                        canvas.style.border = '1px solid #e0e0e0';
                        canvas.style.borderRight = pageNum === pagesToShow[0] ? 'none' : '1px solid #e0e0e0';

                        // ä½¿ç”¨æ›´ä¼˜åŒ–çš„æ¸²æŸ“é…ç½®ï¼Œç¡®ä¿æ¸…æ™°åº¦
                        await page.render({
                            canvasContext: ctx,
                            viewport,
                            enableWebGL: true,
                            renderInteractiveForms: true,
                            // å¢åŠ æ¸²æŸ“è´¨é‡è®¾ç½®
                            quality: 1.0,
                            alpha: false
                        }).promise;
                        
                        contentWrapper.appendChild(canvas);
                    }
                    
                    // å°†å†…å®¹å®¹å™¨æ·»åŠ åˆ°PDFå®¹å™¨ä¸­
                    elements.pdfContainer.appendChild(contentWrapper);

                    // æ›´æ–°é¡µç æ˜¾ç¤º
                    updatePageIndicator(currentPage, pdf.numPages, 'pdf');
                }

                        // ç¿»é¡µå‡½æ•°
                function goToPage(pageNum) {
                    if (pageNum < 1) pageNum = 1;
                    if (pageNum > pdf.numPages) pageNum = pdf.numPages;
                    currentPage = pageNum;
                    
                    // ä¿å­˜é˜…è¯»è¿›åº¦ï¼ŒåŒ…å«æ€»é¡µæ•°ä¿¡æ¯
                    const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                    localStorage.setItem(progressKey, JSON.stringify({ 
                        currentPage, 
                        totalPages: pdf.numPages 
                    }));
                    
                    renderPages();
                }

                // ç»‘å®šé”®ç›˜äº‹ä»¶
                function handleKeyPress(e) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        // å‘å·¦ç¿»é¡µæ—¶ï¼Œå½“å‰é¡µå‡2ï¼ˆå¦‚æœå½“å‰é¡µå¤§äº2ï¼‰ï¼Œå¦åˆ™å‡1
                        const newPage = currentPage > 2 ? currentPage - 2 : 1;
                        goToPage(newPage);
                        console.log('å‘å·¦ç¿»é¡µï¼Œå½“å‰é¡µ:', newPage);
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        // å‘å³ç¿»é¡µæ—¶ï¼Œå½“å‰é¡µåŠ 2ï¼ˆå¦‚æœå½“å‰é¡µå°äºæ€»é¡µæ•°-1ï¼‰ï¼Œå¦åˆ™åŠ 1
                        const newPage = currentPage < pdf.numPages - 1 ? currentPage + 2 : pdf.numPages;
                        goToPage(newPage);
                        console.log('å‘å³ç¿»é¡µï¼Œå½“å‰é¡µ:', newPage);
                    } else if (e.key === '+' || e.key === '=') {
                        e.preventDefault();
                        // æ”¾å¤§
                        if (currentScale < 3.0) {
                            currentScale += 0.2;
                            renderPages();
                            console.log('æ”¾å¤§ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«:', currentScale);
                        }
                    } else if (e.key === '-' || e.key === '_') {
                        e.preventDefault();
                        // ç¼©å°
                        if (currentScale > 0.5) {
                            currentScale -= 0.2;
                            renderPages();
                            console.log('ç¼©å°ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«:', currentScale);
                        }
                    } else if (e.key === '0') {
                        e.preventDefault();
                        // é‡ç½®ç¼©æ”¾
                        currentScale = 1.0;
                        renderPages();
                        console.log('é‡ç½®ç¼©æ”¾ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«:', currentScale);
                    }
                }

                // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬å™¨
                document.addEventListener('keydown', handleKeyPress);
                state.keyPressHandler = handleKeyPress;

                // æ·»åŠ æ‰‹æŒ‡ç¼©æ”¾æ”¯æŒ
                let startDistance = 0;
                let startScale = 1.0;
                
                elements.pdfContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        // è®¡ç®—ä¸¤æŒ‡ä¹‹é—´çš„åˆå§‹è·ç¦»
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        startDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        startScale = currentScale;
                    }
                });
                
                elements.pdfContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        // è®¡ç®—ä¸¤æŒ‡ä¹‹é—´çš„å½“å‰è·ç¦»
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        
                        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                        const scaleFactor = currentDistance / startDistance;
                        const newScale = startScale * scaleFactor;
                        
                        // é™åˆ¶ç¼©æ”¾èŒƒå›´
                        if (newScale >= 0.5 && newScale <= 3.0) {
                            currentScale = newScale;
                            renderPages();
                        }
                    }
                });

                // åˆå§‹åŒ–æ¸²æŸ“
                await renderPages();

                console.log('PDFæ–‡ä»¶æ¸²æŸ“å®Œæˆ');
            } catch (err) {
                console.error(`æ‰“å¼€PDFæ–‡ä»¶å¤±è´¥:`, err);
                elements.pdfContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: #909399;">æ‰“å¼€PDFæ–‡ä»¶å¤±è´¥: ${err.message}</div>`;
            }
        }

        // æ‰“å¼€EPUBé˜…è¯»å™¨
        async function openEpubReader(file, fileName) {
            // æ˜¾ç¤ºé˜…è¯»è§†å›¾
            elements.readerView.style.display = 'flex';
            elements.readerTitle.textContent = fileName;
            elements.pdfContainer.style.display = 'none';
            elements.epubContainer.style.display = 'block';
            elements.epubContainer.innerHTML = '';

            // ç›´æ¥æ˜¾ç¤ºåŠ è½½ä¸­ä¿¡æ¯
            elements.epubContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: #4096ff;">æ­£åœ¨åŠ è½½EPUBæ–‡ä»¶...</div>`;

            try {
                console.log('=== å¼€å§‹å¤„ç†EPUBæ–‡ä»¶ ===');
                console.log('æ–‡ä»¶å:', fileName);
                console.log('æ–‡ä»¶å¤§å°:', file.size);
                console.log('æ–‡ä»¶ç±»å‹:', file.type);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰epubjsåº“
                console.log('æ£€æŸ¥EPUB.jsåº“æ˜¯å¦åŠ è½½...');
                if (typeof ePub === 'undefined') {
                    throw new Error('EPUBé˜…è¯»å™¨åº“æœªåŠ è½½');
                }
                console.log('EPUB.jsåº“åŠ è½½æˆåŠŸ');

                // æ£€æŸ¥å¹¶ç§»é™¤å·²å­˜åœ¨çš„ç›®å½•é¢æ¿ï¼ˆåŒ…æ‹¬PDFçš„ç›®å½•é¢æ¿ï¼‰
                const existingEpubTocPanel = document.getElementById('epub-toc-panel');
                if (existingEpubTocPanel) {
                    existingEpubTocPanel.remove();
                }
                const existingPdfTocPanel = document.getElementById('pdf-toc-panel');
                if (existingPdfTocPanel) {
                    existingPdfTocPanel.remove();
                }

                // ç›´æ¥ä»Fileå¯¹è±¡è¯»å–æ•°æ®ï¼Œä¸ä½¿ç”¨ä¸´æ—¶URL
                console.log('å¼€å§‹è¯»å–EPUBæ–‡ä»¶:', fileName);
                const arrayBuffer = await file.arrayBuffer();
                console.log('EPUBæ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¤§å°:', arrayBuffer.byteLength, 'å­—èŠ‚');
                
                // å°è¯•ä½¿ç”¨æœ€ç®€å•çš„æ–¹å¼åˆ›å»ºEPUBå®ä¾‹
                console.log('åˆ›å»ºEPUBå®ä¾‹...');
                try {
                    // ç›´æ¥ä¼ é€’ArrayBufferç»™ePubæ„é€ å‡½æ•°
                    const book = ePub(arrayBuffer);
                    console.log('EPUBå®ä¾‹åˆ›å»ºæˆåŠŸ');
                    
                    // è®¡ç®—é€‚åˆå±å¹•çš„å°ºå¯¸
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight - 60; // å‡å»å¤´éƒ¨é«˜åº¦
                    
                    console.log('æ¸²æŸ“å°ºå¯¸:', screenWidth, 'x', screenHeight);
                    
                    // åˆ›å»ºé˜…è¯»å†…å®¹åŒºåŸŸï¼ŒåŒ…å«ç›®å½•é¢æ¿å’ŒEPUBå®¹å™¨
                    const readerContent = document.createElement('div');
                    readerContent.style.display = 'flex';
                    readerContent.style.width = '100%';
                    readerContent.style.height = '100%';
                    readerContent.style.overflow = 'hidden';
                    
                    // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°çš„é˜…è¯»å†…å®¹åŒºåŸŸ
                    elements.epubContainer.innerHTML = '';
                    elements.epubContainer.appendChild(readerContent);
                    
                    // åˆ›å»ºEPUBå®¹å™¨ - è°ƒæ•´æ ·å¼ä»¥ç¡®ä¿å†…å®¹å¯è§
                    const epubView = document.createElement('div');
                    epubView.id = 'epub-content';
                    epubView.style.width = '100%';
                    epubView.style.height = '100%';
                    epubView.style.overflow = 'auto';
                    epubView.style.backgroundColor = '#f5f7fa';
                    epubView.style.boxSizing = 'border-box';
                    epubView.style.display = 'flex';
                    epubView.style.justifyContent = 'center';
                    epubView.style.alignItems = 'flex-start';
                    epubView.style.padding = '20px';
                    epubView.style.gap = '0px';
                    epubView.style.flexWrap = 'nowrap';
                    epubView.style.overflowX = 'auto';
                    
                    // åˆå§‹åŒ–ç›®å½•æ•°æ®
                    let epubToc = [];
                    
                    // è·å–EPUBç›®å½•
                    try {
                        await book.loaded.navigation;
                        epubToc = book.navigation.toc;
                        console.log('EPUBç›®å½•è·å–æˆåŠŸï¼Œæ¡ç›®æ•°:', epubToc.length);
                        
                        // ç¼“å­˜ç›®å½•ä¿¡æ¯åˆ°localStorage
                        const outlineKey = `epub_outline_${fileName}_${file.size}_${file.lastModified}`;
                        // è½¬æ¢ç›®å½•æ•°æ®ä¸ºå¯åºåˆ—åŒ–æ ¼å¼
                        const serializableOutline = JSON.parse(JSON.stringify(epubToc));
                        localStorage.setItem(outlineKey, JSON.stringify(serializableOutline));
                    } catch (err) {
                        console.log('EPUBæ— ç›®å½•æˆ–è·å–ç›®å½•å¤±è´¥:', err);
                        epubToc = [];
                    }
                    
                    // å¦‚æœæœ‰ç›®å½•ï¼Œåˆ›å»ºç›®å½•é¢æ¿
                    if (epubToc.length > 0) {
                        // åˆ›å»ºç›®å½•é¢æ¿
                        const tocPanel = document.createElement('div');
                        tocPanel.id = 'epub-toc-panel';
                        tocPanel.style.width = '250px';
                        tocPanel.style.height = '100%';
                        tocPanel.style.backgroundColor = '#f5f7fa';
                        tocPanel.style.borderRight = '1px solid #e4e7ed';
                        tocPanel.style.padding = '15px';
                        tocPanel.style.overflowY = 'auto';
                        tocPanel.style.boxSizing = 'border-box';
                        
                        // æ·»åŠ ç›®å½•æ ‡é¢˜
                        const tocTitle = document.createElement('div');
                        tocTitle.textContent = 'ç›®å½•';
                        tocTitle.style.fontSize = '16px';
                        tocTitle.style.fontWeight = 'bold';
                        tocTitle.style.marginBottom = '15px';
                        tocTitle.style.color = '#303133';
                        tocPanel.appendChild(tocTitle);
                        
                        // æ¸²æŸ“ç›®å½•å‡½æ•°
                        function renderTOC(toc, container, level = 0) {
                            const ul = document.createElement('ul');
                            ul.style.listStyle = 'none';
                            ul.style.padding = '0';
                            ul.style.margin = '0';
                            ul.style.marginLeft = `${level * 15}px`;
                            
                            toc.forEach(item => {
                                const li = document.createElement('li');
                                li.style.marginBottom = '8px';
                                
                                const tocItem = document.createElement('div');
                                tocItem.textContent = item.label;
                                tocItem.style.padding = '6px 10px';
                                tocItem.style.borderRadius = '4px';
                                tocItem.style.cursor = 'pointer';
                                tocItem.style.fontSize = level === 0 ? '14px' : '13px';
                                tocItem.style.color = '#409eff';
                                tocItem.style.whiteSpace = 'nowrap';
                                tocItem.style.overflow = 'hidden';
                                tocItem.style.textOverflow = 'ellipsis';
                                
                                // æ·»åŠ æ‚¬åœæ•ˆæœ
                                tocItem.addEventListener('mouseover', () => {
                                    tocItem.style.backgroundColor = '#ecf5ff';
                                });
                                tocItem.addEventListener('mouseout', () => {
                                    tocItem.style.backgroundColor = 'transparent';
                                });
                                
                                // ç›®å½•é¡¹ç‚¹å‡»äº‹ä»¶
                                tocItem.addEventListener('click', async (e) => {
                                    e.stopPropagation();
                                    // è·³è½¬åˆ°å¯¹åº”ç« èŠ‚
                                    if (item.href) {
                                        try {
                                            console.log('ç›®å½•é¡¹ç‚¹å‡»:', item.label, 'ç›®æ ‡:', item.href);
                                            await rendition.display(item.href);
                                            
                                            // æ›´æ–°å½“å‰ç« èŠ‚
                                            const chapterIndex = epubToc.findIndex(ch => ch.href === item.href);
                                            if (chapterIndex >= 0) {
                                                currentChapter = chapterIndex + 1;
                                                updateEpubPageInfo();
                                                
                                                // ä¿å­˜é˜…è¯»è¿›åº¦
                                                const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                                                localStorage.setItem(progressKey, JSON.stringify({ currentChapter, totalChapters }));
                                            }
                                        } catch (err) {
                                            console.error('ç›®å½•è·³è½¬å¤±è´¥:', err);
                                        }
                                    }
                                });
                                
                                li.appendChild(tocItem);
                                
                                // æ¸²æŸ“å­ç›®å½•
                                if (item.subitems && item.subitems.length > 0) {
                                    // æ·»åŠ å±•å¼€/æŠ˜å æŒ‰é’®
                                    const toggleBtn = document.createElement('span');
                                    toggleBtn.style.display = 'inline-block';
                                    toggleBtn.style.width = '16px';
                                    toggleBtn.style.height = '16px';
                                    toggleBtn.style.textAlign = 'center';
                                    toggleBtn.style.marginRight = '5px';
                                    toggleBtn.style.fontSize = '12px';
                                    toggleBtn.textContent = 'â–¶';
                                    toggleBtn.style.transform = 'rotate(0deg)';
                                    toggleBtn.style.transition = 'transform 0.2s ease';
                                    
                                    tocItem.insertBefore(toggleBtn, tocItem.firstChild);
                                    
                                    // åˆ›å»ºå­ç›®å½•å®¹å™¨
                                    const subContainer = document.createElement('div');
                                    subContainer.style.display = 'none';
                                    li.appendChild(subContainer);
                                    
                                    // ä¸ºå±•å¼€/æŠ˜å æŒ‰é’®æ·»åŠ å•ç‹¬çš„ç‚¹å‡»äº‹ä»¶
                                    toggleBtn.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        if (subContainer.style.display === 'none') {
                                            subContainer.style.display = 'block';
                                            toggleBtn.style.transform = 'rotate(90deg)';
                                            // æ¸²æŸ“å­ç›®å½•
                                            renderTOC(item.subitems, subContainer, level + 1);
                                        } else {
                                            subContainer.style.display = 'none';
                                            toggleBtn.style.transform = 'rotate(0deg)';
                                        }
                                    });
                                }
                                
                                ul.appendChild(li);
                            });
                            
                            container.appendChild(ul);
                        }
                        
                        // æ¸²æŸ“ç›®å½•
                        renderTOC(epubToc, tocPanel);
                        
                        // æ’å…¥ç›®å½•é¢æ¿åˆ°é˜…è¯»å†…å®¹åŒºåŸŸ
                        readerContent.appendChild(tocPanel);
                    }
                    
                    // æ·»åŠ EPUBå®¹å™¨åˆ°é˜…è¯»å†…å®¹åŒºåŸŸ
                    readerContent.appendChild(epubView);

                    console.log('EPUBå®¹å™¨åˆ›å»ºæˆåŠŸï¼Œå°ºå¯¸:', epubView.offsetWidth, 'x', epubView.offsetHeight);
                    
                    const rendition = book.renderTo(epubView, {
                        width: epubView.offsetWidth,
                        height: epubView.offsetHeight,
                        flow: 'paginated',
                        spread: 'always', // å§‹ç»ˆåŒé¢å±•ç¤º
                        method: 'default'
                    });
                    console.log('æ¸²æŸ“å®ä¾‹åˆ›å»ºæˆåŠŸ');

                    // è·å–æ€»ç« èŠ‚æ•°
                    let totalChapters = epubToc.length;
                    console.log('EPUBæ€»ç« èŠ‚æ•°:', totalChapters);

                    // è·å–é˜…è¯»è¿›åº¦
                    const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                    const savedProgress = JSON.parse(localStorage.getItem(progressKey) || '{"currentChapter": 1}');
                    let currentChapter = savedProgress.currentChapter || 1;

                    // æ›´æ–°é¡µç æ˜¾ç¤º
                    function updateEpubPageInfo() {
                        if (totalChapters > 0) {
                            updatePageIndicator(currentChapter, totalChapters, 'epub');
                        }
                    }
                    
                    // ç»‘å®šé”®ç›˜äº‹ä»¶è¿›è¡Œç¿»é¡µå’Œç¼©æ”¾
                    function handleKeyPress(e) {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            rendition.prev();
                            if (currentChapter > 1) {
                                currentChapter--;
                                updateEpubPageInfo();
                                // ä¿å­˜é˜…è¯»è¿›åº¦
                                const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                                localStorage.setItem(progressKey, JSON.stringify({ currentChapter, totalChapters }));
                            }
                            console.log('å‘å·¦ç¿»é¡µï¼Œå½“å‰ç« èŠ‚:', currentChapter);
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            rendition.next();
                            if (currentChapter < totalChapters) {
                                currentChapter++;
                                updateEpubPageInfo();
                                // ä¿å­˜é˜…è¯»è¿›åº¦
                                const progressKey = `reading_progress_${fileName}_${file.size}_${file.lastModified}`;
                                localStorage.setItem(progressKey, JSON.stringify({ currentChapter, totalChapters }));
                            }
                            console.log('å‘å³ç¿»é¡µï¼Œå½“å‰ç« èŠ‚:', currentChapter);
                        }
                    }
                    
                    // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬å™¨
                    document.addEventListener('keydown', handleKeyPress);
                    console.log('é”®ç›˜äº‹ä»¶ç›‘å¬å™¨æ·»åŠ æˆåŠŸ');
                    
                    // ä¿å­˜äº‹ä»¶ç›‘å¬å™¨å¼•ç”¨ï¼Œä»¥ä¾¿åœ¨è¿”å›æ—¶ç§»é™¤
                    state.currentRendition = rendition;
                    state.keyPressHandler = handleKeyPress;
                    
                    // æ¸²æŸ“ç¬¬ä¸€é¡µ
                    console.log('å¼€å§‹æ¸²æŸ“ç¬¬ä¸€é¡µ...');
                    rendition.display().then(function() {
                        console.log('ç¬¬ä¸€é¡µæ¸²æŸ“æˆåŠŸ');
                        updateEpubPageInfo();
                    }).catch(function(error) {
                        console.error('æ¸²æŸ“å¤±è´¥:', error);
                    });
                } catch (bookError) {
                    console.error('åˆ›å»ºEPUBå®ä¾‹å¤±è´¥:', bookError);
                    elements.epubContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: #f56c6c;">åˆ›å»ºEPUBå®ä¾‹å¤±è´¥: ${bookError.message}</div>`;
                }
            } catch (err) {
                console.error('å¤„ç†EPUBæ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯:', err);
                elements.epubContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: #f56c6c;">å¤„ç†EPUBæ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${err.message}<br>è¯¦ç»†é”™è¯¯: ${err.stack}</div>`;
            }
        }

        function createFileInput() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.id = 'file-input';
            fileInput.multiple = true;
            fileInput.accept = '.pdf,.epub,.txt,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.jpg,.png';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            elements.fileInput = fileInput;
        }

        // å·¥å…·å‡½æ•°ï¼šè¯»å– File/Blob ä¸º ArrayBufferï¼ˆå…¼å®¹ä¸¤ç§æ¨¡å¼ï¼‰
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (err) => reject(err);
                reader.readAsArrayBuffer(file);
            });
        }

        function isSupportedFile(fileName) {
            const supportedExts = ['.pdf', '.epub', '.txt', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.jpg', '.png'];
            const ext = fileName.split('.').pop().toLowerCase();
            return supportedExts.some(s => fileName.endsWith(s));
        }

        function getFileTypeName(fileTypeOrName) {
            // å¤„ç†MIMEç±»å‹
            if (fileTypeOrName.includes('/')) {
                const mimeMap = {
                    'application/pdf': 'PDFæ–‡æ¡£',
                    'application/epub+zip': 'EPUBç”µå­ä¹¦',
                    'text/plain': 'æ–‡æœ¬æ–‡æ¡£',
                    'application/msword': 'Wordæ–‡æ¡£',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Wordæ–‡æ¡£',
                    'application/vnd.ms-excel': 'Excelè¡¨æ ¼',
                    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'Excelè¡¨æ ¼',
                    'application/vnd.ms-powerpoint': 'PPTæ¼”ç¤ºæ–‡ç¨¿',
                    'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'PPTæ¼”ç¤ºæ–‡ç¨¿',
                    'image/jpeg': 'å›¾ç‰‡æ–‡ä»¶',
                    'image/png': 'å›¾ç‰‡æ–‡ä»¶'
                };
                if (mimeMap[fileTypeOrName]) {
                    return mimeMap[fileTypeOrName];
                }
            }
            
            // ä»æ–‡ä»¶åè·å–æ‰©å±•å
            const ext = fileTypeOrName.split('.').pop().toLowerCase();
            const typeMap = {
                pdf: 'PDFæ–‡æ¡£',
                epub: 'EPUBç”µå­ä¹¦',
                txt: 'æ–‡æœ¬æ–‡æ¡£',
                doc: 'Wordæ–‡æ¡£',
                docx: 'Wordæ–‡æ¡£',
                xls: 'Excelè¡¨æ ¼',
                xlsx: 'Excelè¡¨æ ¼',
                ppt: 'PPTæ¼”ç¤ºæ–‡ç¨¿',
                pptx: 'PPTæ¼”ç¤ºæ–‡ç¨¿',
                jpg: 'å›¾ç‰‡æ–‡ä»¶',
                png: 'å›¾ç‰‡æ–‡ä»¶'
            };
            return typeMap[ext] || 'æœªçŸ¥æ–‡ä»¶';
        }

        function getFileIcon(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            const iconMap = {
                txt: 'ğŸ“',
                doc: 'ğŸ“„', docx: 'ğŸ“„',
                xls: 'ğŸ“Š', xlsx: 'ğŸ“Š',
                ppt: 'ğŸ“‹', pptx: 'ğŸ“‹',
                jpg: 'ğŸ–¼ï¸', png: 'ğŸ–¼ï¸',
                epub: 'ğŸ“–', pdf: 'ğŸ“„'
            };
            return iconMap[ext] || 'ğŸ“';
        }

        function showEmptyState() {
            elements.emptyState.style.display = 'flex';
            elements.fileGrid.style.display = 'none';
        }

        function hideEmptyState() {
            elements.emptyState.style.display = 'none';
            elements.fileGrid.style.display = 'grid';
        }

        // æ›´æ–°é¡µç æ˜¾ç¤º
        function updatePageIndicator(currentPage, totalPages, type) {
            if (!elements.readerPageInfo) return;
            
            const percentage = Math.round((currentPage / totalPages) * 100);
            elements.readerPageInfo.textContent = `${currentPage} / ${totalPages} (${percentage}%)`;
        }

        // è·å–é˜…è¯»è¿›åº¦
        function getReadingProgress(fileName, fileSize, lastModified) {
            const progressKey = `reading_progress_${fileName}_${fileSize}_${lastModified}`;
            return JSON.parse(localStorage.getItem(progressKey) || 'null');
        }

        // ä¿å­˜é˜…è¯»è¿›åº¦
        function saveReadingProgress(fileName, fileSize, lastModified, currentPage, totalPages) {
            const progressKey = `reading_progress_${fileName}_${fileSize}_${lastModified}`;
            const progressData = {
                currentPage,
                totalPages,
                percentage: Math.round((currentPage / totalPages) * 100),
                lastRead: Date.now()
            };
            localStorage.setItem(progressKey, JSON.stringify(progressData));
        }
    </script>
</body>
</html>
